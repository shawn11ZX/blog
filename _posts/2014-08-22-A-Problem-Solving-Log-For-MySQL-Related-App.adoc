---
layout: post
title: A problem soving log for Mysql related Application
---

:toc: macro
:toclevels: 4
:sectnums:
:imagesdir: /images
:hp-tags: Mysql

== 问题

*   联通一区（x.x.x.219）GameLogic有大量请求堵塞
*   对应时间点的error.log包含如下信息：

**   The last packet successfully received from the server was 1,200,245 milliseconds ago.

*  Coder 说8/21号RefreshUserDataTask因未捕捉到异常而退出。run.log与其描述匹配

== 原因分析


GameLogic的的请求处理只有一个线程，而该线程需要访问两个数据库，一旦阻塞就会堵住。

一般客户端和MySQL的交互流程如下：

1.  客户端向MySQL建立连接
2.  客户端向MySQL发送数据 http://dev.mysql.com/doc/internals/en/com-stmt-prepare.html[COM_STMT_PREPARE]指令和 http://dev.mysql.com/doc/internals/en/com-stmt-execute.html[COM_STMT_EXECUTE]
3.  客户端（等待）读取MySQL的数据
4.  MySQL执行，执行完毕后，返回数据给客户端
5.  客户端读取到数据

第1步可以可以设置超时，超时时间由connectTimeout控制，默认不超时，因此这里是**潜在的堵塞点（如MySQL所在机器关闭的情况下) **

如果在第4步，网络断开，则第5步会一直等待，直到：

*   读超时（socketTimeout参数）
*   或者连接被复位*   

=== 连接复位和Keep Alive

连接被复位发生在TCP层，发生的前提是一端向另一端发了个报文，而另一端的OS发现该连接不合法就会发送RSET报文。因此该机制与MySQL无关

在进程从TCP连接读数据时，是不会发报文出去的，需要靠TCP的Keep Alive机制。每个TCP连接可以选择是否打开该功能，MySQL Connector允许通过**tcpKeepAlive**设置，且默认情况下是打开的。

每个连接只能选择是否打开Keep Alive而不能设置具体的参数，具体的参数是整个OS统一的。在CentOS中可以通过查看如下文件获得：

*   /proc/sys/net/ipv4/tcp_keepalive_time，x.x.x.219上是1200
*   /proc/sys/net/ipv4/tcp_keepalive_intvl，x.x.x.219上是75
*   /proc/sys/net/ipv4/tcp_keepalive_probes，x.x.x.219上是9

因此x.x.x.219上打开Keep Alive的TCP连接会每隔1200秒发送一个Keep Alive报文，如果没有回复会每隔75秒再发一个，直到发送9个


=== 今天的情况

*   error.log中的1200毫秒应该是tcp keep alive时间，根据服务器的配置，可以看出。
*   原因应该是在执行上述第3步后，网络断开了
*   当MySQL执行完成后，需要向客户端写回数据。写回超过net_write_timeout秒后MySQL断开连接。这个net_write_timeout会在每次客户端调用ExecuteXXX时，被客户端设置为netTimeoutForStreamingResults后（默认600毫秒）。
*   这时，网络恢复了。客户端仍然在等待读到数据。
*   等待Keep Alive超时，客户端向MySQL发送Keep Alive报文，MySQL所在OS马上发送RESET回来。
*   客户端抛出异常后继续执行。

=== 为什么平时没问题

*   **gamelogic有个**RefreshUserDataTask定时向MySQL发送SELECT NOW语句，过程如下：

*   第一步从一个Connection获得一个PreparedStatement。这步向MySQL发送了http://dev.mysql.com/doc/internals/en/com-stmt-prepare.html[COM_STMT_PREPARE]指令，导致提前触发了RESET
*   第二部执行ExecuteQuery。需要注意两个ExecuteQuery是互斥的，一个进去了另外一个不会进去。所以这步对触发RESET没效果*   今天这个线程已经挂掉了……

== 总结

目前看来到MySQL的连接应该经常断，才会出现刚才的情况。有以下情况会发生较长时间等待，从而导致阻塞

*   发送MySQL连接请求时，MySQL服务器关闭
*   读取连接数据时，MySQL服务器被断电，或者网络断开
*   写入连接数据时，MySQL服务器被断电，或者网络断开

客户端最好把到Center的SQL连接放到独立的线程处理，否则即时设了读超时，也会在未超时时间内，发送阻塞。  

== **参考**

* http://frankfan915.iteye.com/blog/1672465[Communications link failure错误分析]  
* http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html[Using TCP keepalive under Linux]  
* http://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html[Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J]  
  
